ALTER TABLE cards DROP COLUMN id;

ALTER TABLE cards
ADD id INT AUTO_INCREMENT PRIMARY KEY;




INSERT INTO cards (id, qtype, question, answer, correct_option, options) VALUES
(DEFAULT, 'Arrays', 'Explain the difference between a static array and a dynamic array.', 'Static arrays have a fixed size determined at creation, while dynamic arrays can grow or shrink as needed.', 'Static arrays have a fixed size; dynamic arrays can resize.', ARRAY['Static arrays can resize, dynamic arrays have a fixed size.', 'Static arrays are stored in contiguous memory, dynamic arrays can be scattered.', 'Static arrays have a fixed size; dynamic arrays can resize.', 'Dynamic arrays are immutable, static arrays are mutable.']),
(DEFAULT, 'Strings', 'What is the difference between mutable and immutable strings?', 'Mutable strings allow modifications after their creation, while immutable strings remain constant.', 'Mutable strings can be changed; immutable strings cannot.', ARRAY['Mutable strings cannot be changed; immutable strings can be changed.', 'Mutable strings are fixed size; immutable strings can vary in size.', 'Mutable strings can be changed; immutable strings cannot.', 'Mutable strings are stored in contiguous memory; immutable strings are not.']),
(DEFAULT, 'Strings', 'Describe the concept of string interning.', 'String interning involves reusing immutable strings to optimize memory usage.', 'Reusing immutable strings to save memory.', ARRAY['Storing strings in separate memory locations to avoid duplication.', 'Reusing immutable strings to save memory.', 'Encoding strings for encryption.', 'Compressing strings to reduce size.']),
(DEFAULT, 'Queues', 'What is a circular queue, and how does it differ from a regular queue?', 'A circular queue connects the end of the queue back to the front, allowing for efficient reuse of space. A regular queue does not have this feature and simply dequeues elements from the front and enqueues at the rear without wrapping.', 'Circular queue wraps around; regular queue does not.', ARRAY['Circular queue wraps around; regular queue does not.', 'Circular queue uses a priority-based ordering; regular queue follows FIFO.', 'Circular queue supports only one type of data; regular queue supports multiple data types.', 'Circular queue has a fixed size; regular queue can dynamically grow.']),
(DEFAULT, 'Linked Lists', 'What is the primary advantage of using a linked list over an array?', 'Singly linked lists have a single pointer to the next node, while doubly linked lists have pointers to both the next and previous nodes.', 'Efficient insertion and deletion.', ARRAY['Faster access times for elements.', 'More memory usage for storing elements.', 'Efficient insertion and deletion.', 'Fixed size storage.']),
(DEFAULT, 'Stacks', 'What is the stack data structure, and what are its main operations?', 'A stack is a Last-In-First-Out (LIFO) data structure with primary operations of pushing, popping, and peeking.', 'LIFO structure with operations: push, pop, peek.', ARRAY['LIFO structure with operations: push, pop, peek.', 'FIFO structure with operations: enqueue, dequeue, front.', 'A structure that supports random access with operations: add, remove.', 'A structure for priority management with operations: insert, delete.']),
(DEFAULT, 'Stacks', 'Explain the concept of stack overflow and stack underflow.', 'Stack overflow occurs when a stack exceeds its allocated size, and underflow occurs when operations are attempted on an empty stack.', 'Overflow: Stack exceeds capacity; Underflow: Stack is empty.', ARRAY['Overflow: Stack is empty; Underflow: Stack exceeds capacity.', 'Overflow: Stack exceeds capacity; Underflow: Stack is empty.', 'Overflow: Stack has too many elements; Underflow: Stack has too few elements.', 'Overflow: Stack is full; Underflow: Stack is full.']),
(DEFAULT, 'Arrays', 'What is the time complexity of accessing an element in an array?', 'The time complexity of accessing an element in an array is O(1), which means it is done in constant time. This is because arrays are stored in contiguous memory locations, and the index allows direct access.', 'O(1)', ARRAY['O(n)', 'O(log n)', 'O(1)', 'O(n^2)']),
(DEFAULT, 'Linked Lists', 'What are the differences between singly linked lists and doubly linked lists?', 'Singly linked lists have a single pointer to the next node, while doubly linked lists have pointers to both the next and previous nodes.', 'Singly linked lists have one pointer per node; doubly linked lists have two.', ARRAY['Singly linked lists have two pointers per node; doubly linked lists have one.', 'Singly linked lists have one pointer per node; doubly linked lists have two.', 'Singly linked lists are faster for insertion; doubly linked lists are slower.', 'Singly linked lists are static; doubly linked lists are dynamic.']),
(DEFAULT, 'Queues', 'Describe the difference between a priority queue and a regular queue.', 'In a priority queue, elements are dequeued based on their priority rather than the order they were enqueued. In contrast, a regular queue follows the FIFO (First In, First Out) principle.', 'Priority queue sorts elements by priority; regular queue follows FIFO.', ARRAY['Priority queue sorts elements by priority; regular queue follows FIFO.', 'Priority queue uses a circular structure; regular queue does not.', 'Priority queue supports multiple priorities; regular queue supports single priority.', 'Priority queue is always empty; regular queue is never empty.']),
(DEFAULT, 'Trees', 'What are the characteristics of a binary search tree (BST)?', 'In a binary search tree, for any given node, the value of the left child is less than the node’s value, and the value of the right child is greater than the node’s value.', 'Left child < Node < Right child.', ARRAY['Left child = Node > Right child.', 'Left child > Node < Right child.', 'Left child < Node < Right child.', 'Left child < Node = Right child.']),
(DEFAULT, 'Trees', 'Explain what is meant by a balanced binary tree.', 'A balanced binary tree ensures that the difference in height between the left and right subtrees of any node is at most one, maintaining balanced performance.', 'Heights of subtrees differ by at most one.', ARRAY['Nodes have an equal number of children.', 'All levels are completely filled.', 'All leaves are at the same level.', 'Heights of subtrees differ by at most one.']),
(DEFAULT, 'Hashing', 'What is a hash function, and why is it important in hashing?', 'A hash function converts input data into a fixed-size value (hash code), which is used for efficient data retrieval and indexing, especially in hash tables.', 'Maps input to a fixed-size value; crucial for indexing.', ARRAY['Maps input to a fixed-size value; crucial for indexing.', 'Encrypts data to ensure privacy.', 'Compresses data to reduce size.', 'Orders data in a sequential manner.']),
(DEFAULT, 'Sorting Algorithms', 'Explain the concept of the time complexity of sorting algorithms.', 'Computational complexity describes how the runtime or space requirements of an algorithm grow with respect to the size of the input.', 'Measures the computational cost relative to input size.', ARRAY['Measures the computational cost relative to input size.', 'Measures the speed of the algorithm in seconds.', 'Measures the physical memory usage of the algorithm.', 'Measures the number of lines of code in the algorithm.']),
(DEFAULT, 'Greedy Algorithms', 'What is the difference between a greedy algorithm and a dynamic programming algorithm?', 'Greedy algorithms focus on making the best choice at each step, while dynamic programming solves all subproblems and combines their solutions to ensure an optimal solution for the overall problem.', 'Greedy algorithms make immediate optimal choices; dynamic programming solves all subproblems.', ARRAY['Greedy algorithms solve all subproblems; dynamic programming makes immediate optimal choices.', 'Greedy algorithms make immediate optimal choices; dynamic programming solves all subproblems.', 'Greedy algorithms use memoization; dynamic programming uses tabulation.', 'Greedy algorithms are slower; dynamic programming is faster.']),
(DEFAULT, 'Graphs', 'What is the difference between a directed graph and an undirected graph?', 'In directed graphs, edges have a direction, indicating the relationship from one vertex to another. In undirected graphs, edges do not have direction, representing a bidirectional relationship.', 'Directed graphs have edges with direction; undirected do not.', ARRAY['Directed graphs have edges with direction; undirected do not.', 'Directed graphs have weighted edges; undirected graphs do not.', 'Directed graphs are cyclic; undirected graphs are acyclic.', 'Directed graphs have a fixed number of vertices; undirected graphs do not.']),
(DEFAULT, 'Graphs', 'Explain the concept of a topological sort.', 'Topological sorting gives a linear ordering of vertices in a Directed Acyclic Graph (DAG) such that for every directed edge from vertex A to vertex B, vertex A comes before vertex B in the ordering.', 'Linear ordering of vertices.', ARRAY['Circular ordering of vertices.', 'Linear ordering of vertices.', 'Hierarchical ordering of vertices.', 'Random ordering of vertices.']),
(DEFAULT, 'Hashing', 'What is collision resolution in hashing?', 'Chaining involves storing colliding elements in a linked list at each hash table index, allowing multiple elements to share the same hash code.', 'Chaining.', ARRAY['Sorting.', 'Chaining.', 'Merging.', 'Partitioning.']),
(DEFAULT, 'Sorting Algorithms', 'What is the difference between stable and unstable sorting algorithms?', 'A stable sorting algorithm maintains the relative order of elements with equal values, while an unstable algorithm does not guarantee this.', 'Stable algorithms preserve order of equal elements; unstable do not.', ARRAY['Stable algorithms use less memory; unstable algorithms use more memory.', 'Stable algorithms are faster; unstable algorithms are slower.', 'Stable algorithms preserve order of equal elements; unstable do not.', 'Stable algorithms work only with integers; unstable algorithms work with any data type.']),
(DEFAULT, 'Dynamic Programming', 'What is the difference between memoization and tabulation in dynamic programming?', 'Memoization solves problems in a top-down manner by storing results of subproblems as they are computed. Tabulation solves problems in a bottom-up manner by filling out a table iteratively.', 'Memoization is top-down; tabulation is bottom-up.', ARRAY['Memoization is top-down; tabulation is bottom-up.', 'Memoization is bottom-up; tabulation is top-down.', 'Memoization uses less memory; tabulation uses more memory.', 'Memoization is faster; tabulation is slower.']),
(DEFAULT, 'Dynamic Programming', 'What is the principle of optimality in dynamic programming?', 'Dynamic programming relies on solving smaller subproblems optimally and combining their solutions to solve the overall problem optimally.', 'Optimal solutions to subproblems lead to an optimal solution.', ARRAY['Dividing a problem into unrelated subproblems.', 'Immediate optimal choices lead to a global optimum.', 'Optimal solutions to subproblems lead to an optimal solution.', 'Randomly selecting solutions to subproblems.']),
(DEFAULT, 'Greedy Algorithms', 'What is the greedy method, and when is it used?', 'Greedy algorithms make the best immediate choice at each step with the hope of finding the global optimum. They are effective when local optimal choices lead to a global optimum solution.', 'Makes locally optimal choices; used when local optimum leads to global optimum.', ARRAY['Requires backtracking to ensure optimal solutions.', 'Solves all subproblems to find the global optimum.', 'Ignores immediate choices and solves the problem randomly.', 'Makes locally optimal choices; used when local optimum leads to global optimum.']);




